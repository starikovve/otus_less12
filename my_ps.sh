#!/bin/bash

# Выводим заголовок, имитируя ps ax
echo -e "PID\tTTY\tSTAT\tTIME\tCOMMAND"

# 1. Используем find для поиска всех цифровых директорий в /proc (это PID процессов)
# sort -n используется для сортировки по возрастанию номеров (опционально)
for pid_dir in $(find /proc -maxdepth 1 -name "[0-9]*" | sort -n); do
    
    # Получаем чистый PID из имени папки
    pid=$(basename "$pid_dir")
    
    # Проверяем, существует ли файл stat (процесс мог исчезнуть во время работы скрипта)
    if [ -r "$pid_dir/stat" ]; then
        
        # Читаем содержимое файла stat
        stat_line=$(cat "$pid_dir/stat")
        
        # --- ПАРСИНГ STAT ---
        # Проблема: имя процесса (comm) в поле 2 в скобках может содержать пробелы.
        # Например: (Web Content). Это ломает простой разбив по пробелам.
        
        # Решение: Удаляем всё от начала строки до ПОСЛЕДНЕЙ закрывающей скобки.
        # То есть отрезаем PID и (COMM).
        # Используем встроенные возможности bash для работы со строками.
        rest_of_line="${stat_line##*)}"
        
        # Используем 'set', чтобы разобрать оставшуюся строку на аргументы $1, $2, ...
        # В этот момент $1 становится состоянием процесса (State), так как мы отрезали начало.
        set -- $rest_of_line
        
        # Теперь:
        # $1 - State (изначально 3-е поле)
        # $5 - TTY nr (изначально 7-е поле)
        # $12 - utime (user time, изначально 14-е поле)
        # $13 - stime (system time, изначально 15-е поле)
        
        STATE=$1
        TTY_NR=$5
        UTIME=${12}
        STIME=${13}
        
        # --- РАСЧЕТ ВРЕМЕНИ (TIME) ---
        # Время в Linux хранится в "тиках" (обычно 100 тиков в секунду)
        # Суммируем пользовательское и системное время
        total_ticks=$((UTIME + STIME))
        # Делим на 100, чтобы получить секунды
        seconds=$((total_ticks / 100))
        # Переводим в формат ММ:СС
        mm=$((seconds / 60))
        ss=$((seconds % 60))
        
        # --- ОБРАБОТКА TTY ---
        # Если номер TTY равен 0, значит терминала нет (?)
        if [ "$TTY_NR" -eq "0" ]; then
            TTY="?"
        else
            # Упрощение: настоящий ps мапит номера устройств в имена (/dev/pts/0).
            # В bash это сложно, поэтому выводим просто номер.
            TTY="$TTY_NR"
        fi
        
        # --- ПОЛУЧЕНИЕ КОМАНДЫ (COMMAND) ---
        # Настоящий ps берет полную команду из /proc/PID/cmdline.
        # Аргументы там разделены null-байтами (\0).
        # Используем 'tr', чтобы заменить \0 на пробелы.
        CMD=$(tr '\0' ' ' < "$pid_dir/cmdline" 2>/dev/null)
        
        # Если cmdline пуст (это бывает у процессов ядра), берем имя из файла stat
        if [ -z "$CMD" ]; then
            # Здесь используем cut, чтобы вырезать текст внутри скобок из оригинальной строки
            # cut -d '(' -f2 берет всё после первой скобки
            # cut -d ')' -f1 берет всё до закрывающей скобки
            # Добавляем квадратные скобки [], как это делает ps для процессов ядра
            raw_name=$(echo "$stat_line" | cut -d '(' -f2 | rev | cut -d ')' -f2- | rev)
            CMD="[$raw_name]"
        fi
        
        # Выводим строку. printf помогает выровнять колонки.
        printf "%s\t%s\t%s\t%02d:%02d\t%s\n" "$pid" "$TTY" "$STATE" "$mm" "$ss" "$CMD"
        
    fi
done
